{"version":3,"sources":["visualizer/Node/Node.jsx","Nav/NavBar.jsx","visualizer/algorithms/dijkstra.js","visualizer/algorithms/astar.js","visualizer/PathFinder.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","props","classNames","isStart","isFinish","isWall","nodeTracker","id","row","col","className","onClick","handleMouseClick","onMouseDown","mouseDown","onMouseUp","mouseUp","onMouseEnter","mouseEnter","NavBar","VisualizeDijkstra","VisualizeAstar","resetButton","dijkstra","grid","startNode","finishNode","distance","vistedNodes","unvistedNodes","allNodes","node","push","length","sortNodesDistance","closestNode","shift","Infinity","visited","updateUnvisitedNeighborsDOWN","sort","a","b","unvistedNeighbors","getUnvisitedNeighbors","getNeighbors","neighbors","getAllNeighbors","diagonalNeighbors","getDiagonalNeighbors","diagonal","nodes","previousNode","testPrevious","console","log","filter","astar","f","g","sortNodesF","updateUnvisitedNeighbors","heuristic","currentNode","Math","abs","h","START_ROW","START_COL","FINISH_ROW","FINISH_COL","PathFinder","useState","setGrid","mousePressed","mouse","setMouse","getInitialGrid","useCallback","initialGrid","currentRow","createNode","useEffect","animateShortestPath","shortestPath","i","setTimeout","document","getElementById","removeVisted","START","FINISH","visitedNodesforAnimation","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animateDijkstra","astarShortest","animateAstar","element","j","map","rowId","key","nodeId","newGrid","slice","newNode","testGrid","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d4abfa8c.chunk.js","sourcesContent":["import React, { useState } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nconst Node = (props) => {\r\n  const classNames = props.isStart\r\n    ? \"node-start\"\r\n    : props.isFinish\r\n    ? \"node-finish\"\r\n    : props.isWall\r\n    ? \"node-wall\"\r\n    : \"\";\r\n\r\n  const nodeTracker = props.nodeTracker ? \"node-tracker\" : \"\";\r\n\r\n  return (\r\n    <div\r\n      id={`node-${props.row}-${props.col}`}\r\n      className={`node ${classNames} ${nodeTracker}`}\r\n      onClick={() => props.handleMouseClick(props.row, props.col)}\r\n      onMouseDown={() => props.mouseDown(props.row, props.col)}\r\n      onMouseUp={() => props.mouseUp(props.row, props.col)}\r\n      onMouseEnter={() => props.mouseEnter(props.row, props.col)}\r\n    ></div>\r\n  );\r\n};\r\nexport default Node;\r\n","import React from \"react\";\r\nimport \"./NavBar.css\";\r\nconst NavBar = (props) => {\r\n  return (\r\n    <div className=\"navbar-container\">\r\n      <button onClick={() => props.VisualizeDijkstra()}>\r\n        Visualize Dijkstras\r\n      </button>\r\n      <button onClick={() => props.VisualizeAstar()}>Visualize A*</button>\r\n      <button onClick={() => props.resetButton()}>Reset Board</button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default NavBar;\r\n","export function dijkstra(grid, startNode, finishNode) {\r\n  startNode.distance = 0;\r\n  const vistedNodes = [];\r\n  const unvistedNodes = allNodes(grid);\r\n  while (!!unvistedNodes.length) {\r\n    sortNodesDistance(unvistedNodes);\r\n    const closestNode = unvistedNodes.shift();\r\n    if (closestNode.isWall) continue;\r\n    if (closestNode.distance === Infinity) return vistedNodes;\r\n    closestNode.visited = true;\r\n    vistedNodes.push(closestNode);\r\n    if (closestNode === finishNode) return vistedNodes;\r\n    updateUnvisitedNeighborsDOWN(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesDistance(unvistedNodes) {\r\n  unvistedNodes.sort((a, b) => a.distance - b.distance);\r\n}\r\n\r\n// makes weighted when going down\r\nfunction updateUnvisitedNeighborsDOWN(node, grid) {\r\n  const unvistedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  const getNeighbors = getAllNeighbors(node, grid);\r\n  const diagonalNeighbors = getDiagonalNeighbors(node, grid);\r\n  node.diagonal = diagonalNeighbors;\r\n  for (const nodes of unvistedNeighbors) {\r\n    nodes.distance = node.distance + 1;\r\n    nodes.previousNode = node;\r\n  }\r\n  for (const neighbors of getNeighbors) {\r\n    node.testPrevious.push(neighbors);\r\n  }\r\n  console.log(node.testPrevious);\r\n}\r\n\r\n// makes weighted going up\r\nfunction updateUnvisitedNeighborsUP(node, grid) {\r\n  const unvistedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  const diagonalNeighbors = getDiagonalNeighbors(node, grid);\r\n  node.diagonal = diagonalNeighbors;\r\n  for (const nodes of unvistedNeighbors) {\r\n    const { row, col } = nodes;\r\n    const previous = nodes.previousNode;\r\n    nodes.distance = node.distance + 1;\r\n    nodes.previousNode = node;\r\n  }\r\n}\r\nfunction updateUnvisitedNeighborsNEUTRAL(node, grid) {\r\n  const unvistedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const nodes of unvistedNeighbors) {\r\n    nodes.distance = node.distance + 1;\r\n    nodes.previousNode = node;\r\n  }\r\n}\r\n\r\nexport function getDiagonalNeighbors(node, grid) {\r\n  const diagonalNeighbors = [];\r\n  const { row, col } = node;\r\n  if (row === 0 && col === 0) {\r\n    diagonalNeighbors.push(grid[row + 1][col + 1]);\r\n    return diagonalNeighbors;\r\n  }\r\n  if (row === 0 && col === 49) {\r\n    diagonalNeighbors.push(grid[row + 1][col - 1]);\r\n    return diagonalNeighbors;\r\n  }\r\n  if (row === 19 && col === 0) {\r\n    diagonalNeighbors.push(grid[row - 1][col + 1]);\r\n    return diagonalNeighbors;\r\n  }\r\n  if (row === 19 && col === 49) {\r\n    diagonalNeighbors.push(grid[row - 1][col - 1]);\r\n    return diagonalNeighbors;\r\n  }\r\n  if (row === 0) {\r\n    diagonalNeighbors.push(grid[row + 1][col - 1], grid[row + 1][col + 1]);\r\n    return diagonalNeighbors;\r\n  }\r\n  if (row === 19) {\r\n    diagonalNeighbors.push(grid[row - 1][col - 1], grid[row - 1][col + 1]);\r\n    return diagonalNeighbors;\r\n  }\r\n  if (col === 0) {\r\n    diagonalNeighbors.push(grid[row + 1][col + 1], grid[row - 1][col + 1]);\r\n    return diagonalNeighbors;\r\n  }\r\n  if (col === 49) {\r\n    diagonalNeighbors.push(grid[row + 1][col - 1], grid[row - 1][col - 1]);\r\n    return diagonalNeighbors;\r\n  }\r\n  if (row > 0)\r\n    diagonalNeighbors.push(grid[row - 1][col - 1], grid[row - 1][col + 1]);\r\n  if (row < grid.length - 1)\r\n    diagonalNeighbors.push(grid[row + 1][col - 1], grid[row + 1][col + 1]);\r\n  return diagonalNeighbors;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbors) => !neighbors.visited);\r\n}\r\n\r\nfunction getAllNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors;\r\n}\r\n\r\nfunction allNodes(grid) {\r\n  const allNodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      allNodes.push(node);\r\n    }\r\n  }\r\n  return allNodes;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function astar(grid, startNode, finishNode) {\r\n  startNode.f = 0;\r\n  startNode.g = 0;\r\n  const vistedNodes = [];\r\n  const unvistedNodes = allNodes(grid);\r\n  while (unvistedNodes.length) {\r\n    sortNodesF(unvistedNodes);\r\n    const closestNode = unvistedNodes.shift();\r\n    if (closestNode.isWall) continue;\r\n    // no solution\r\n    if (closestNode.f === Infinity) return vistedNodes;\r\n    closestNode.visited = true;\r\n    vistedNodes.push(closestNode);\r\n    if (closestNode === finishNode) return vistedNodes;\r\n    // for animation\r\n    updateUnvisitedNeighbors(closestNode, grid, finishNode);\r\n  }\r\n}\r\n\r\nfunction sortNodesF(unvistedNodes) {\r\n  unvistedNodes.sort((a, b) => a.f - b.f);\r\n}\r\n\r\nfunction heuristic(currentNode, finishNode) {\r\n  const h =\r\n    Math.abs(currentNode.col - finishNode.col) +\r\n    Math.abs(currentNode.row - finishNode.row);\r\n  return h;\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\r\n  const unvistedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const nodes of unvistedNeighbors) {\r\n    nodes.g = node.g + 1;\r\n    nodes.previousNode = node;\r\n    nodes.h = heuristic(nodes, finishNode);\r\n    nodes.f = nodes.g + nodes.h;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  // for (let i = 0; i < diagonalNeighbors.length; i++) {\r\n  //   neighbors.push(diagonalNeighbors[i]);\r\n  // }\r\n  return neighbors.filter((neighbors) => !neighbors.visited);\r\n}\r\n\r\nfunction getAllNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors;\r\n}\r\n\r\nfunction allNodes(grid) {\r\n  const allNodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      allNodes.push(node);\r\n    }\r\n  }\r\n  return allNodes;\r\n}\r\n\r\nexport function astarShortest(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React, { useState, useEffect, useCallback } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport NavBar from \"../Nav/NavBar\";\r\nimport \"./PathFinder.css\";\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"./algorithms/dijkstra\";\r\nimport { astar, astarShortest } from \"./algorithms/astar.js\";\r\n\r\nlet START_ROW = 10;\r\nlet START_COL = 5;\r\nlet FINISH_ROW = 10;\r\nlet FINISH_COL = 45;\r\nlet GRID_LENGTH = 50;\r\nlet GRID_HEIGHT = 20;\r\nconst PathFinder = (props) => {\r\n  const [grid, setGrid] = useState([]);\r\n  const [mouse, setMouse] = useState({\r\n    mousePressed: false,\r\n    isStart: false,\r\n    isFinish: false,\r\n  });\r\n  const getInitialGrid = useCallback(() => {\r\n    const initialGrid = [];\r\n    for (let row = 0; row < GRID_HEIGHT; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < GRID_LENGTH; col++) {\r\n        const currentNode = createNode(col, row);\r\n        currentRow.push(currentNode);\r\n      }\r\n      initialGrid.push(currentRow);\r\n    }\r\n    return initialGrid;\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    console.log(FINISH_COL, FINISH_ROW);\r\n    const nodes = getInitialGrid();\r\n    setGrid(nodes);\r\n  }, [getInitialGrid]);\r\n\r\n  const createNode = (col, row) => {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row == START_ROW && col == START_COL,\r\n      isFinish: row == FINISH_ROW && col == FINISH_COL,\r\n      distance: Infinity,\r\n      visited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      testPrevious: [],\r\n      mousePressed: false,\r\n      nodeTracker: false,\r\n      diagonal: [],\r\n      f: Infinity,\r\n      g: Infinity,\r\n      h: 0,\r\n    };\r\n  };\r\n\r\n  function animateDijkstra(visitedNodesforAnimation) {\r\n    for (let i = 0; i < visitedNodesforAnimation.length; i++) {\r\n      if (i + 1 === visitedNodesforAnimation.length) {\r\n        const shortestPath = getNodesInShortestPathOrder(\r\n          grid[FINISH_ROW][FINISH_COL]\r\n        );\r\n        setTimeout(() => {\r\n          animateShortestPath(shortestPath);\r\n        }, 7 * i);\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesforAnimation[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 7 * i);\r\n    }\r\n  }\r\n\r\n  function animateAstar(visitedNodesforAnimation) {\r\n    for (let i = 0; i < visitedNodesforAnimation.length; i++) {\r\n      if (i + 1 === visitedNodesforAnimation.length) {\r\n        const shortestPath = astarShortest(grid[FINISH_ROW][FINISH_COL]);\r\n        setTimeout(() => {\r\n          animateShortestPath(shortestPath);\r\n        }, 5 * i);\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesforAnimation[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 5 * i);\r\n    }\r\n  }\r\n\r\n  function animateShortestPath(shortestPath) {\r\n    for (let i = 0; i < shortestPath.length; i++) {\r\n      setTimeout(() => {\r\n        const node = shortestPath[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest\";\r\n      }, 30 * i);\r\n    }\r\n  }\r\n\r\n  function VisualizeDijkstra() {\r\n    removeVisted();\r\n    const START = grid[START_ROW][START_COL];\r\n    const FINISH = grid[FINISH_ROW][FINISH_COL];\r\n    const visitedNodesforAnimation = dijkstra(grid, START, FINISH);\r\n    animateDijkstra(visitedNodesforAnimation);\r\n  }\r\n\r\n  function VisualizeAstar() {\r\n    removeVisted();\r\n    const START = grid[START_ROW][START_COL];\r\n    const FINISH = grid[FINISH_ROW][FINISH_COL];\r\n    const visitedNodesforAnimation = astar(grid, START, FINISH);\r\n    animateAstar(visitedNodesforAnimation);\r\n  }\r\n\r\n  function handleMouseClick(row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = { ...node, isWall: !node.isWall };\r\n    newGrid[row][col] = newNode;\r\n    setGrid(newGrid);\r\n  }\r\n\r\n  function mouseDown(row, col) {\r\n    if (row == START_ROW && col == START_COL) {\r\n      setMouse({\r\n        mousePressed: true,\r\n        isStart: true,\r\n        isFinish: false,\r\n      });\r\n    } else if (row == FINISH_ROW && col == FINISH_COL) {\r\n      setMouse({\r\n        mousePressed: true,\r\n        isStart: false,\r\n        isFinish: true,\r\n      });\r\n    } else {\r\n      setMouse({\r\n        mousePressed: true,\r\n        isStart: false,\r\n        isFinish: false,\r\n      });\r\n    }\r\n  }\r\n\r\n  function mouseUp(row, col) {\r\n    setMouse({\r\n      mousePressed: false,\r\n      isStart: false,\r\n      isFinish: false,\r\n    });\r\n  }\r\n  function mouseEnter(row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    if (mouse.mousePressed && mouse.isFinish) {\r\n      FINISH_ROW = row;\r\n      FINISH_COL = col;\r\n      const testGrid = getInitialGrid();\r\n      const newNode = { ...node, isFinish: FINISH_ROW && FINISH_COL };\r\n      testGrid[row][col] = newNode;\r\n      setGrid(testGrid);\r\n    } else if (mouse.mousePressed && mouse.isStart) {\r\n      START_ROW = row;\r\n      START_COL = col;\r\n      const testGrid = getInitialGrid();\r\n      const newNode = { ...node, isStart: START_ROW && START_COL };\r\n      testGrid[row][col] = newNode;\r\n      setGrid(testGrid);\r\n    } else if (mouse.mousePressed) {\r\n      const newNode = { ...node, isWall: true };\r\n      newGrid[row][col] = newNode;\r\n      setGrid(newGrid);\r\n    }\r\n  }\r\n\r\n  function resetButton() {\r\n    for (let row = 0; row < 20; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < 50; col++) {\r\n        if (col === START_COL && row === START_ROW) {\r\n          document.getElementById(`node-${row}-${col}`).className =\r\n            \"node node-start\";\r\n        } else if (col === FINISH_COL && row === FINISH_ROW) {\r\n          document.getElementById(`node-${row}-${col}`).className =\r\n            \"node node-finish\";\r\n        } else {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n\r\n    setGrid(getInitialGrid());\r\n  }\r\n\r\n  function removeVisted() {\r\n    for (let i = 0; i < grid.length; i++) {\r\n      const element = grid[i];\r\n      for (let j = 0; j < element.length; j++) {\r\n        if (element[j].isWall) {\r\n          continue;\r\n        }\r\n        if (element[j].isStart) {\r\n          document.getElementById(\r\n            `node-${element[j].row}-${element[j].col}`\r\n          ).className = \"node node-start\";\r\n        } else if (element[j].isFinish) {\r\n          document.getElementById(\r\n            `node-${element[j].row}-${element[j].col}`\r\n          ).className = \"node node-finish\";\r\n        } else {\r\n          document.getElementById(\r\n            `node-${element[j].row}-${element[j].col}`\r\n          ).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"main-container\">\r\n      <NavBar\r\n        VisualizeDijkstra={() => VisualizeDijkstra()}\r\n        resetButton={() => resetButton()}\r\n        VisualizeAstar={() => VisualizeAstar()}\r\n        removeVisted={() => removeVisted()}\r\n      ></NavBar>\r\n      <div className=\"main-grid\">\r\n        {grid.map((row, rowId) => {\r\n          return (\r\n            <div key={rowId}>\r\n              {row.map((node, nodeId) => (\r\n                <Node\r\n                  key={nodeId}\r\n                  col={node.col}\r\n                  row={node.row}\r\n                  isStart={node.isStart}\r\n                  isFinish={node.isFinish}\r\n                  isWall={node.isWall}\r\n                  visited={node.visited}\r\n                  nodeTracker={node.nodeTracker}\r\n                  handleMouseClick={(row, col) => handleMouseClick(row, col)}\r\n                  mouseDown={(row, col) => mouseDown(row, col)}\r\n                  mouseUp={(row, col) => mouseUp(row, col)}\r\n                  mouseEnter={(row, col) => mouseEnter(row, col)}\r\n                ></Node>\r\n              ))}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PathFinder;\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport \"./visualizer/PathFinder\";\r\nimport PathFinder from \"./visualizer/PathFinder\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\n\r\nconst App = props => {\r\n  return (\r\n    <div>\r\n      <PathFinder></PathFinder>;\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}